var documenterSearchIndex = {"docs":
[{"location":"api/private/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"api/private/#Sampling-grid","page":"Internal API","title":"Sampling grid","text":"","category":"section"},{"location":"api/private/#ChargeFlipPhaser.find_injective_projector","page":"Internal API","title":"ChargeFlipPhaser.find_injective_projector","text":"find_injective_projector(dd::DiffractionData{N,D,T}; num_candidates=10)::Tuple{SVector{N,T},T} where {N,D,T<:Integer}\n\nConstruct a cyclic anti-aliasing sampling grid and returns it generator\n\nArguments\n\ndd::DiffractionData: The diffraction data object.\nnum_candidates::Int: The number of candidate projectors to try.\n\nReturns\n\nA tuple containing the integer vector representing the generator of the cyclic anti-aliasing sampling grid and the maximal scalar product of this vector with the wave vectors in the diffraction data.\nIt is guaranteed that all scalar\n\n\n\n\n\n","category":"function"},{"location":"api/private/#ChargeFlipPhaser.basis_of_dense_packing","page":"Internal API","title":"ChargeFlipPhaser.basis_of_dense_packing","text":"basisofdense_packing(n::Int)::Matrix{Float64}\n\nGenerate a basis for the lattice corresponding to dense packing of spheres of radius 1 in n-dimensional space.    Produces the known densest packings in dimensions from 1 to 8, for higher dimensions falls back     to the D_n lattice.    Parameters:     - n: The dimension of the space.    Returns:     - An n×n Float64 matrix, where each column represents a basis vector of the lattice.\n\n\n\n\n\n","category":"function"},{"location":"api/private/#ChargeFlipPhaser.basis_dn","page":"Internal API","title":"ChargeFlipPhaser.basis_dn","text":"basis_dn(n::Int)::Matrix{Float64}\n\nGenerate a basis for the lattice Dn with the distance between the nearest neighbors equal to 2.    Parameters:     - n: The dimension of the lattice.    Returns:     - An n×n Float64 matrix, where each column represents a basis vector of the lattice Dn.\n\n\n\n\n\n","category":"function"},{"location":"api/private/#ChargeFlipPhaser.basis_e678","page":"Internal API","title":"ChargeFlipPhaser.basis_e678","text":"basis_e678(dim::Int)::Matrix{Float64}\n  \nGenerate a basis for the E6, E7, or E8 lattice with the distance between the nearest neighbors equal to 2.\nParameters:\n - `dim`: The dimension of the lattice (6, 7, or 8).\nReturns:\n - An n×n Float64 matrix, where each column represents a basis vector of the E_n lattice.\n\n\n\n\n\n","category":"function"},{"location":"api/private/#Miscellaneous","page":"Internal API","title":"Miscellaneous","text":"","category":"section"},{"location":"api/private/#ChargeFlipPhaser.BraggPeaksOrbit","page":"Internal API","title":"ChargeFlipPhaser.BraggPeaksOrbit","text":"BraggPeaksOrbit{N,T<:Integer}\n\nA structure representing an orbit of Bragg peaks in a diffraction pattern.    Type parameters:     - N: The number of dimensions (e.g., 3 for 3D diffraction patterns).     - T: The type of the integer used for indexing (e.g., Int).    The BraggPeaksOrbit structure is used to store information about a specific    Bragg peak in a diffraction pattern. It contains the orbit of wave vectors    containing the Bragg peak, as well as the intensity of the peak.    The structure contains the following fields:\n\no: A PhysicalOrbit object representing the orbit of wave vectors    associated with the Bragg peaks.\nI: The intensity of the Bragg peak.\n\n\n\n\n\n","category":"type"},{"location":"api/private/#ChargeFlipPhaser.DefaultHooks","page":"Internal API","title":"ChargeFlipPhaser.DefaultHooks","text":"DefaultHooks <: AbstractHooks\n\nHook implementation providing the default behavior for the phasing workflow.\n\nDefaultHooks performs no interactive operations and is suitable for unattended batch execution or automated scripts.\n\n\n\n\n\n","category":"type"},{"location":"api/private/#ChargeFlipPhaser.F0WaasKirf","page":"Internal API","title":"ChargeFlipPhaser.F0WaasKirf","text":"F0WaasKirf\n\nCallable object representing the non-dispersive part f_0 of the atomic scattering factor for an element or ion. The representation follows  the formulas from this article: New Analytical Scattering Factor Functions for Free Atoms and Ions for Free  Atoms and Ions, D. Waasmaier & A. Kirfel, Acta Cryst. (1995). A51, 416-413                      \n\nThe non-dispersive part f_0 of the atomic scattering factor is a\t     function of the selected element and of kappa=sin(theta)lambda,  where lambda is the photon wavelengh and theta is incident angle.\t\t     This function can be approximated by a function:\t\t\t    \n\nf_0(kappa) = c + sum_i=1^5 a_i exp(-b_i*(kappa^2)) \t\t\t\t    \n\nFields\n\nsym: The chemical symbol of the element or ion (e.g., \"Fe\", \"Fe2+\", \"O2-\")\nz: The atomic number of the element or ion (e.g., 26 for Fe)\na: The vector of coefficients for the exponential terms in the scattering factor\nb: The vector of coefficients for the exponential decay in the scattering factor\nc: The constant term in the scattering factor\n\nThe object should be called with a single real argument κ = sin(θ)  λ.\n\n\n\n\n\n","category":"type"},{"location":"api/private/#ChargeFlipPhaser.Cutter","page":"Internal API","title":"ChargeFlipPhaser.Cutter","text":"Cutter\n\nData structure for efficiently computing a 2D section (cut) of the charge density.\n\nFields\n\nphaser::Phaser   The phasing engine providing the amplitudes and lattice information.\ncut::Cut2D   The 2D section specification.\nfproj::Matrix{ComplexF64}   Projection of the amplitudes onto the cutting plane.\nρ::Matrix{Float64}   The computed density values on the 2D cut.\nf2fproj1::SparseMatrixCSC{ComplexF64}   Sparse matrix converting 1D amplitudes to the cut for the original directions.\nf2fproj2::SparseMatrixCSC{ComplexF64}   Sparse matrix for the antipodal directions.\nfproj2ρ   IRFFT plan for converting the projected amplitudes to real-space density.\n\n\n\n\n\n","category":"type"},{"location":"api/private/#ChargeFlipPhaser.alias","page":"Internal API","title":"ChargeFlipPhaser.alias","text":"alias(k::SVector{M,Int}, size::NTuple{M,Int}) -> NTuple{M,Int}\n\nConvert an integer vector k into 1-based indices suitable for FFT arrays.\n\nArguments\n\nk::SVector{M,Int}: The input integer vector (e.g., a lattice index).\nsize::NTuple{M,Int}: The dimensions of the FFT grid.\n\nReturns\n\nNTuple{M,Int}: 1-based indices corresponding to k, wrapped modulo the grid size.\n\nNotes\n\nThis ensures that negative or out-of-bounds indices are correctly mapped into the valid FFT array range.\n\n\n\n\n\n","category":"function"},{"location":"api/private/#ChargeFlipPhaser.save_result","page":"Internal API","title":"ChargeFlipPhaser.save_result","text":"save_result(saver::CSVSaver, phaser::Phaser, wa::WorkingAmplitudes)\n\nSave the results to a CSV file.\n\nThe output file has the following columns:\n\nk1, k2, ..., kn: The reflection indices.\nI: The peak intensity (the value is taken from the DiffractionData object).\nreal(ampl): The real part of the amplitude.\nimag(ampl): The imaginary part of the amplitude.\n\nNote that the absolute value of the amplitude is not necessarity equal to  the square root of the intensity, because of the form-factors used in the phasing.\n\n\n\n\n\n","category":"function"},{"location":"#ChargeFlipPhaser.jl","page":"Home","title":"ChargeFlipPhaser.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia toolkit for dual-space phasing algorithm development.","category":"page"},{"location":"api/public/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"api/public/#Input-data","page":"API Reference","title":"Input data","text":"","category":"section"},{"location":"api/public/#Symmetry-and-lattice-parameters","page":"API Reference","title":"Symmetry and lattice parameters","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.DiffractionData","page":"API Reference","title":"ChargeFlipPhaser.DiffractionData","text":"DiffractionData{N,D,T<:Integer}\n\nA structure representing a diffraction pattern in N-dimensional space.    Type parameters:     - N: The number of dimensions of the reciprocal lattice.     - D: The number of dimensions of the real space. For the periodic crystals,          D is equal to N.     - T: The type of the integer used for indexing (e.g., Int).    The DiffractionData structure is used to store information about a    diffraction pattern, including the Bragg peaks and their intensities.    The structure contains the following fields:     - G: A SpaceGroupQuotient object representing the symmetry group of the         structure.     - md: The metric data of the crystal structure, represented by a DxN static          matrix. Given the integer N-dimensional vector k, the value of the corresponding         diffraction wavevector is md*k. For the real physical data, the units of md are Å^-1     - bps: A vector of BraggPeaksOrbit objects representing the orbits of Bragg peaks         in the diffraction pattern.     - k_to_bp: A dictionary mapping wave vectors to their corresponding         BraggPeaksOrbit objects. This field is used to efficiently check if a         wave vector is already present in the diffraction pattern and to retrieve         the associated Bragg peak orbit when needed. It ensures that each wave         vector is uniquely associated with a single Bragg peak orbit.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.metric_data_inconsistency","page":"API Reference","title":"ChargeFlipPhaser.metric_data_inconsistency","text":"metric_data_inconsistency(dd::DiffractionData{N,D,T})::Float64 where {N,D,T<:Integer}\nCheck for inconsistencies in the metric data of the `DiffractionData` object.\nParameters:\n- `dd`: The `DiffractionData` object to check.\nFor the metric data `md` to be consistent with the symmetry group, the matrix `r=md'*md`\nmust be invariant with respect to the action of the symmetry group `G`. Namely, for every \nelement g∈G, the following condition must hold:\n`g.a'*r*g.a = r`\nThis function computes the matrix `r` and returns the tolerance to which this condition is satisfied.\nReturns:\n- The ratio of the maximal absolute value of of the elements of the matrix `g.a'*r*g.a - r` to the \ntrace of `r`. This value should be close to zero for the metric data to be consistent with the symmetry group.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ChargeFlipPhaser.physicalnorm","page":"API Reference","title":"ChargeFlipPhaser.physicalnorm","text":"physicalnorm(k::SVector{N, T}, dd::DiffractionData{N,D,T}) where {N,D,T<:Integer}\n\nCompute the norm of a physical wave vector corresponding to the integer vector kusing     the metric data of the DiffractionData object.     Parameters:     - k: An integer wave vector (a vector of Miller indices).     - dd: The DiffractionData object containing the metric data.    Returns:     - The physical norm of the physical wave vector corresponding to k, calculated as norm(dd.md*k).\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Reflections","page":"API Reference","title":"Reflections","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.add_peak!","page":"API Reference","title":"ChargeFlipPhaser.add_peak!","text":"add_peak!(dd::DiffractionData{N,D,T}, k::SVector{N,T}, I::AbstractFloat)\n\nAdd a new orbit of Bragg peaks to the DiffractionData object.    Parameters:     - dd: The DiffractionData object to which the Bragg peak will be added.     - k: A vector representing the wave vector of the Bragg peak.     - I: The intensity of the Bragg peak.    This function creates a new BraggPeaksOrbit object      and adds it to the DiffractionData object.\n\nIf the wave vector belongs to an extinct orbit, the function will     throw an ArgumentError.\n\nReturn value:     - the number of Bragg peaks in the added orbit. If the wavevector is already     taken into account, the function will return 0.     \n\n\n\n\n\n","category":"function"},{"location":"api/public/#Form-factors","page":"API Reference","title":"Form factors","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.WeightedF0","page":"API Reference","title":"ChargeFlipPhaser.WeightedF0","text":"WeightedF0\n\nA callable object representing the weighted non-dispersive part of the atomic  scattering factor for a material of a given composition.\n\nFields\n\nv: A vector of tuples, where each tuple contains the F0WaasKirf object for \n\nan atom or ion and the fraction of this type of atoms in the material.\n\nConstructors\n\nWeightedF0(c::Vector{Tuple{String, Float64}}): Creates a WeightedF0 object \n\nfrom a vector of tuples, where each tuple contains the chemical symbol of the  atom or ion and its fraction in the material.\n\nExample\n\nThe object should be called with a single real argument κ = sin(θ)  λ.\n\njulia> w=WeightedF0([(\"As\", 1.0), (\"Ga\", 1.0)]); [w(κ) for κ in 0.0:0.2:1.0]\n6-element Vector{Float64}:\n 32.00163144733964\n 25.58541327156792\n 19.004924495418177\n 13.806263061220022\n 10.184215575459087\n  8.03425166926575\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.formfactors_synthetic","page":"API Reference","title":"ChargeFlipPhaser.formfactors_synthetic","text":"formfactors_synthetic(dd::DiffractionData, windowing_function::Function)::Vector{Float64}\n\nComputes the regularizing part of the form factors to use with the diffraction data.\n\nArguments\n\ndd::DiffractionData: The diffraction data object.\nwindowing_function::Function: The regularizing windowing function to apply.\n\nReturns\n\nA vector of form factors.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Running-the-program","page":"API Reference","title":"Running the program","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.Phaser","page":"API Reference","title":"ChargeFlipPhaser.Phaser","text":"Phaser{N}\n\nData structure representing the phaser state.\n\nFields\n\ndd: The diffraction data object.\nreal_orbits: The indices of the real orbits in the diffraction data.\ncomplex_orbits: The indices of the complex orbits in the diffraction data.\nv: The generator of the cyclic sampling grid.\nnumamps: The number of 1D amplitudes, not counting the antipodes and the zero wavevector.\nampl: The vector of the absolute values of amplitudes, in the order of orbits in dd.\np2f_r: Sparse matrix used to set amplitudes for real orbits.\np2f_c1: Sparse matrix used to set amplitudes for complex orbits.\np2f_c2: Sparse matrix used to set amplitudes for complex orbits, conjugated.\nf: The vector of phased amplitudes (on the reciprocal sampling grid)\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.ball_autocorr","page":"API Reference","title":"ChargeFlipPhaser.ball_autocorr","text":"ball_autocorr(x::Float64)::Float64\n\nSpherical ball autocorrelation function\n\nComputes the autocorrelation function of the indicator functions of two  three-dimensional spherical balls of diameter 1. The result is normalized  to 1 at the origin.\n\nParameters\n\nx: The distance from the center of the balls, normalized to the radius \n\n(which is 0.5).\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ChargeFlipPhaser.do_phasing!","page":"API Reference","title":"ChargeFlipPhaser.do_phasing!","text":"do_phasing!(phaser::Phaser; algorithm::AbstractPhasingAlgorithm,\nhooks::AbstractHooks=DefaultHooks(), saver::AbstractSaver=DefaultSaver(),\nmax_iterations::Int=1000)\n\nPerform the phasing algorithm on the given Phaser object.\n\nParameters\n\nphaser: The Phaser object to modify.\nalgorithm: The phasing algorithm to use.\nhooks: The hooks to call during the phasing process.\nsaver: The saver to use for saving results.\nmax_iterations: The maximum number of iterations to perform.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#GUI-monitor","page":"API Reference","title":"GUI monitor","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.PhasingMonitor","page":"API Reference","title":"ChargeFlipPhaser.PhasingMonitor","text":"PhasingMonitor\n\nGUI monitor for the phasing application.\n\nFields\n\nfig::Figure   Makie Figure representing the monitor's GUI window.\nops::Observable{PhasingStatus}   Observable triggering widget redraws whenever the phasing status changes.\nolimits::Observable{Tuple{Float64, Float64}}   Observable for the extrema of the charge density, used to update the corresponding label in the GUI.\nc::Condition   Condition object used to notify the main program about user events.\nstate::Observable{MonitorState}   Current state of the monitor window (Created, Running, or Paused).\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.Cut2D","page":"API Reference","title":"ChargeFlipPhaser.Cut2D","text":"Cut2D{N}\n\nRepresentation of a 2D section (cut) of the charge density in an N-dimensional lattice.\n\nType Parameters\n\nN: The dimension of the problem.\n\nFields\n\ndirection::SMatrix{2,N}   A 2×N matrix whose columns are the lattice vectors spanning the cutting plane.\norigin::SVector{N,Float64}   Coordinates of the origin of the cutting plane in N-dimensional space.\nsize::Tuple{Int,Int}   The dimensions of the grid on which the density cut is computed.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.add_panel!","page":"API Reference","title":"ChargeFlipPhaser.add_panel!","text":"add_panel!(pm::PhasingMonitor, (i, j)::Tuple, cut::Cut2D, title::String, aspect::Real)\n\nAdd a panel to the GUI monitor window to visualize a 2D section of the charge density.\n\nThe panel is placed at grid position (i, j) within the monitor layout and is dynamically updated whenever the phasing status or charge-density limits change.\n\nArguments\n\npm::PhasingMonitor: The monitor window to which the panel will be added.\n(i, j)::Tuple: Grid coordinates (row, column) in the monitor's layout.\ncut::Cut2D: The specification of the 2D section to visualize.\ntitle::String: Title displayed above the panel.\naspect::Real: Aspect ratio of the panel's axes.\n\nNotes\n\nThe charge density cut is computed using a Cutter constructed from pm's current Phaser.\nPanel content updates automatically via observables linked to pm.ops and pm.olimits.\nDecorations are hidden for a cleaner visual layout.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ChargeFlipPhaser.display","page":"API Reference","title":"ChargeFlipPhaser.display","text":"display(pm::PhasingMonitor)\n\nDisplay the GUI window of a phasing monitor.\n\nThis calls Base.display on the underlying Makie figure (pm.fig), bringing up the monitor window for user interaction.\n\nArguments\n\npm::PhasingMonitor: The monitor whose GUI window should be displayed.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ChargeFlipPhaser.MonitorHooks","page":"API Reference","title":"ChargeFlipPhaser.MonitorHooks","text":"MonitorHooks <: AbstractHooks\n\nHooks for integrating the phasing workflow with a PhasingMonitor GUI.\n\nMonitorHooks wraps a PhasingMonitor instance and can be passed to the phasing engine so that GUI updates occur automatically at key points in the workflow.\n\nFields\n\npm::PhasingMonitor   The GUI monitor window to be updated during phasing.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#Custom-phasing-algorithms","page":"API Reference","title":"Custom phasing algorithms","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.AbstractPhasingAlgorithm","page":"API Reference","title":"ChargeFlipPhaser.AbstractPhasingAlgorithm","text":"AbstractPhasingAlgorithm\n\nAbstract supertype for all phasing algorithms in ChargeFlipPhaser.\n\nTo define a new algorithm, create a subtype:\n\nstruct MyAlgorithm <: AbstractPhasingAlgorithm\n    # fields\nend\n\nand implement the following methods:\n\nflip_charge!(rho::Vector{Float64}, algorithm::MyAlgorithm)\nflip_amplitudes!(wa::WorkingAmplitudes, algorithm::MyAlgorithm)\n\nThese methods are part of the ChargeFlipPhaser API. They should be either imported before definition:\n\n    import ChargeFlipPhaser: flip_charge!, flip_amplitudes!\n\nor defined with the module prefix:\n\n    function ChargeFlipPhaser.flip_charge!(...)\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.WorkingAmplitudes","page":"API Reference","title":"ChargeFlipPhaser.WorkingAmplitudes","text":"WorkingAmplitudes\n\n\n\n\n\n","category":"type"},{"location":"api/public/#Modifying-program-behavior","page":"API Reference","title":"Modifying program behavior","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.AbstractHooks","page":"API Reference","title":"ChargeFlipPhaser.AbstractHooks","text":"AbstractHooks\n\nAbstract supertype for hooks used in the phasing process. To define a new hooks type, create a subtype:\n\nstruct MyHooks <: AbstractHooks\n    # fields\nend\n\nand implement the following methods:\n\non_go(hooks::MyHooks)\non_show(hooks::MyHooks, phaser::Phaser,  ρ::Vector{Float64}, iteration::Int)\nis_done(hooks::MyHooks)\n\nThese methods are part of the ChargeFlipPhaser API. They should be either imported before definition:\n\n    import ChargeFlipPhaser: on_go, on_show, is_done\n\nor defined with the module prefix:\n\n    function ChargeFlipPhaser.on_show(...)\n\n\n\n\n\n","category":"type"},{"location":"api/public/#Saving-results","page":"API Reference","title":"Saving results","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.AbstractSaver","page":"API Reference","title":"ChargeFlipPhaser.AbstractSaver","text":"AbstractSaver\n\nAbstract supertype for saving results. To define a new saver type, create a subtype:\n\nstruct MySaver <: AbstractSaver\n    # fields\nend\n\nand implement the following method:\n\nfunction save_result(saver::MySaver, phaser::Phaser, wa::WorkingAmplitudes)\n\nThis method is part of the ChargeFlipPhaser API. It should be either imported before definition:\n\n    import ChargeFlipPhaser: save_result\n\nor defined with the module prefix:\n\n    function ChargeFlipPhaser.save_result(...)\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.CSVSaver","page":"API Reference","title":"ChargeFlipPhaser.CSVSaver","text":"CSVSaver <: AbstractSaver\n\nType for saving results in CSV format.\n\nFields\n\noutput_file_path: The path to the output CSV file where results will be saved.\n\n\n\n\n\n","category":"type"}]
}
