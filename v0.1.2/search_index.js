var documenterSearchIndex = {"docs":
[{"location":"api/private/#Internal-API","page":"Internal API","title":"Internal API","text":"","category":"section"},{"location":"api/private/#Sampling-grid","page":"Internal API","title":"Sampling grid","text":"","category":"section"},{"location":"api/private/#ChargeFlipPhaser.find_injective_projector","page":"Internal API","title":"ChargeFlipPhaser.find_injective_projector","text":"find_injective_projector(dd::DiffractionData{N,D,T}; num_candidates=10)::Tuple{SVector{N,T},T} where {N,D,T<:Integer}\n\nConstruct a cyclic anti-aliasing sampling grid and return its generator\n\nArguments\n\ndd::DiffractionData: The diffraction data object.\nnum_candidates::Int: The number of candidate projectors to try.\n\nReturns\n\nA tuple containing the integer vector representing the generator of the cyclic anti-aliasing sampling grid and the maximal scalar product of this vector with the wave vectors in the diffraction data.\n\n\n\n\n\n","category":"function"},{"location":"api/private/#ChargeFlipPhaser.basis_of_dense_packing","page":"Internal API","title":"ChargeFlipPhaser.basis_of_dense_packing","text":"basis_of_dense_packing(n::Int)::Matrix{Float64}\n\nGenerate a basis for the lattice corresponding to the densest known packing of spheres in n-dimensional space.\n\nArguments\n\nn: The dimension of the space (must be a positive integer).\n\nReturns\n\nAn n×n Matrix{Float64} where each column represents a basis vector of the lattice.\n\nDetails\n\nProduces the known densest packings in dimensions from 1 to 8. For higher dimensions, falls back to the Dₙ lattice.\n\nThe sphere packing uses spheres of radius 1 centered at the lattice points.\n\nExamples\n\njulia> basis_of_dense_packing(2)  # Returns basis for hexagonal packing in 2D\n2×2 Matrix{Float64}:\n 2.0  1.0\n 0.0  1.73205\n\n\n\n\n\n","category":"function"},{"location":"api/private/#ChargeFlipPhaser.basis_dn","page":"Internal API","title":"ChargeFlipPhaser.basis_dn","text":"basis_dn(n::Int)::Matrix{Float64}\n\nGenerate a basis for the Dₙ lattice with nearest-neighbor distance 2.\n\nArguments\n\nn: The dimension of the lattice (must be a positive integer).\n\nReturns\n\nAn n×n Matrix{Float64} where each column represents a basis vector of the Dₙ lattice.\n\nDetails\n\nThe Dₙ lattice is defined such that the minimal distance between lattice points is 2. \n\nFor n ≥ 3, this corresponds to the root lattice of the SO(2n) Lie algebra.\n\nExamples\n\njulia> ChargeFlipPhaser.basis_dn(3)  # Basis for the D₃ lattice (cubic FCC in 3D)\n3×3 Matrix{Float64}:\n 1.41421  1.41421  0.0\n 0.0      1.41421  1.41421\n 1.41421  0.0      1.41421\n\n\n\n\n\n","category":"function"},{"location":"api/private/#ChargeFlipPhaser.basis_e678","page":"Internal API","title":"ChargeFlipPhaser.basis_e678","text":"basis_e678(dim::Int)::Matrix{Float64}\n\nGenerate a basis for the E₆, E₇, or E₈ root lattice with nearest-neighbor distance 2.\n\nArguments\n\ndim: The dimension of the lattice (must be 6, 7, or 8).\n\nReturns\n\nA dim×dim Matrix{Float64} where each column represents a basis vector of the Eₙ lattice.\n\nDetails\n\nThe Eₙ lattices are exceptional root lattices with minimal distance 2 between lattice points:\n\nE₈: The unique even unimodular lattice in 8D (densest sphere packing in ℝ⁸).\nE₇: A 7D lattice related to one of the exceptional Lie algebras.\nE₆: A 6D lattice related to one of the exceptional Lie algebras.\n\n\n\n\n\n","category":"function"},{"location":"api/private/#Miscellaneous","page":"Internal API","title":"Miscellaneous","text":"","category":"section"},{"location":"api/private/#ChargeFlipPhaser.BraggPeaksOrbit","page":"Internal API","title":"ChargeFlipPhaser.BraggPeaksOrbit","text":"BraggPeaksOrbit{N,T<:Integer}\n\nA structure representing an orbit of Bragg peaks in a diffraction pattern.\n\nType parameters:\n\nN: The number of dimensions (e.g., 3 for 3D diffraction patterns).\nT: The type of the integer used for indexing (e.g., Int).\n\nFields\n\no: A PhysicalOrbit object representing the orbit of wave vectors       associated with the Bragg peaks.\nI: The intensity of the Bragg peak.\n\n\n\n\n\n","category":"type"},{"location":"api/private/#ChargeFlipPhaser.DefaultHooks","page":"Internal API","title":"ChargeFlipPhaser.DefaultHooks","text":"DefaultHooks <: AbstractHooks\n\nHook implementation providing the default behavior for the phasing workflow.\n\nDefaultHooks performs no interactive operations and is suitable for unattended batch execution or automated scripts.\n\n\n\n\n\n","category":"type"},{"location":"api/private/#ChargeFlipPhaser.F0WaasKirf","page":"Internal API","title":"ChargeFlipPhaser.F0WaasKirf","text":"F0WaasKirf\n\nCallable object representing the non-dispersive part f_0 of the atomic scattering factor for an element or ion. The representation follows  the formulas from this article: New Analytical Scattering Factor Functions for Free Atoms and Ions for Free  Atoms and Ions, D. Waasmaier & A. Kirfel, Acta Cryst. (1995). A51, 416-413                      \n\nThe non-dispersive part f_0 of the atomic scattering factor is a\t     function of the selected element and of kappa=sin(theta)lambda,  where lambda is the photon wavelengh and theta is incident angle.\t\t     This function can be approximated by a function:\t\t\t    \n\nf_0(kappa) = c + sum_i=1^5 a_i exp(-b_ikappa^2) \t\t\t\t    \n\nFields\n\nsym: The chemical symbol of the element or ion (e.g., \"Fe\", \"Fe2+\", \"O2-\")\nz: The atomic number of the element or ion (e.g., 26 for Fe)\na: The vector of coefficients for the exponential terms in the scattering factor\nb: The vector of coefficients for the exponential decay in the scattering factor\nc: The constant term in the scattering factor\n\nThe object should be called with a single real argument κ = sin(θ)  λ.\n\n\n\n\n\n","category":"type"},{"location":"api/private/#ChargeFlipPhaser.Cutter","page":"Internal API","title":"ChargeFlipPhaser.Cutter","text":"Cutter\n\nData structure for efficiently computing a 2D section (cut) of the charge density.\n\nFields\n\nphaser::Phaser   The phasing engine providing the amplitudes and lattice information.\ncut::Cut2D   The 2D section specification.\nfproj::Matrix{ComplexF64}   Projection of the amplitudes onto the cutting plane.\nρ::Matrix{Float64}   The computed density values on the 2D cut.\nf2fproj1::SparseMatrixCSC{ComplexF64}   Sparse matrix converting 1D amplitudes to the cut for the original directions.\nf2fproj2::SparseMatrixCSC{ComplexF64}   Sparse matrix for the antipodal directions.\nfproj2ρ   IRFFT plan for converting the projected amplitudes to real-space density.\n\n\n\n\n\n","category":"type"},{"location":"api/private/#ChargeFlipPhaser.alias","page":"Internal API","title":"ChargeFlipPhaser.alias","text":"alias(k::SVector{M,Int}, size::NTuple{M,Int}) -> NTuple{M,Int}\n\nConvert an integer vector k into 1-based indices suitable for FFT arrays.\n\nArguments\n\nk::SVector{M,Int}: The input integer vector (e.g., a lattice index).\nsize::NTuple{M,Int}: The dimensions of the FFT grid.\n\nReturns\n\nNTuple{M,Int}: 1-based indices corresponding to k, wrapped modulo the grid size.\n\nNotes\n\nThis ensures that negative or out-of-bounds indices are correctly mapped into the valid FFT array range.\n\n\n\n\n\n","category":"function"},{"location":"api/private/#ChargeFlipPhaser.save_result","page":"Internal API","title":"ChargeFlipPhaser.save_result","text":"save_result(saver::CSVSaver, phaser::Phaser, wa::WorkingAmplitudes)\n\nSave the results to a CSV file.\n\nThe output file has the following columns:\n\nk1, k2, ..., kn: The reflection indices.\nI: The peak intensity (the value is taken from the DiffractionData object).\nreal(ampl): The real part of the amplitude.\nimag(ampl): The imaginary part of the amplitude.\n\nNote that the absolute value of the amplitude is not necessarity equal to  the square root of the intensity, because of the form-factors used in the phasing.\n\nArguments\n\nsaver::CSVSaver: The CSV saver instance.\nphaser::Phaser: The phaser instance containing the diffraction data.\nwa::WorkingAmplitudes: The current working amplitudes to save.\n\n\n\n\n\n","category":"function"},{"location":"api/private/#ChargeFlipPhaser.PhasingStatus","page":"Internal API","title":"ChargeFlipPhaser.PhasingStatus","text":"PhasingStatus\n\nContainer for the current status of the phasing process, used for GUI updates.\n\nFields\n\nphaser::Phaser The phaser instance being monitored.\nρ::Vector{Float64} The current charge density.\niteration::Int The current iteration number.\n\n\n\n\n\n","category":"type"},{"location":"api/private/#ChargeFlipPhaser.MonitorState","page":"Internal API","title":"ChargeFlipPhaser.MonitorState","text":"MonitorState\n\nEnumeration representing the state of the phasing monitor GUI.\n\nValues\n\nCreated: The monitor has been created but not started.\nRunning: The monitor is actively running and updating.\nPaused: The monitor is paused and not updating.\n\n\n\n\n\n","category":"type"},{"location":"api/private/#ChargeFlipPhaser.format_limits","page":"Internal API","title":"ChargeFlipPhaser.format_limits","text":"FormatLimits\n\nFormat the limits for display in the GUI.\n\nArguments\n\nlimits::Tuple{Float64, Float64}: The limits to format.\n\nReturns\n\nString: The formatted limits string.\n\n\n\n\n\n","category":"function"},{"location":"#ChargeFlipPhaser.jl","page":"Home","title":"ChargeFlipPhaser.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A Julia toolkit for dual-space phasing algorithm development.","category":"page"},{"location":"api/public/#Public-API","page":"API Reference","title":"Public API","text":"","category":"section"},{"location":"api/public/#Input-data","page":"API Reference","title":"Input data","text":"","category":"section"},{"location":"api/public/#Symmetry-and-lattice-parameters","page":"API Reference","title":"Symmetry and lattice parameters","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.DiffractionData","page":"API Reference","title":"ChargeFlipPhaser.DiffractionData","text":"DiffractionData{N,D,T<:Integer}\n\nA structure representing a diffraction pattern in N-dimensional space.\n\nThe DiffractionData structure is used to store information about a diffraction pattern, including the Bragg peaks and their intensities.\n\nType parameters:\n\nN: The number of dimensions of the reciprocal lattice.\nD: The number of dimensions of the real space. For the periodic crystals,        D is equal to N.\nT: The type of the integer used for indexing (e.g., Int).\n\nFields\n\nG: A SpaceGroupQuotient object representing the symmetry group of the       structure.\nmd: The metric data of the crystal structure, represented by a DxN static        matrix. Given the integer N-dimensional vector k, the value of the corresponding       diffraction wavevector is md*k. For the real physical data, the units of md are Å^-1\nbps: A vector of BraggPeaksOrbit objects representing the orbits of Bragg peaks       in the diffraction pattern.\nk_to_bp: A dictionary mapping wave vectors to their corresponding       BraggPeaksOrbit objects. This field is used to efficiently check if a       wave vector is already present in the diffraction pattern and to retrieve       the associated Bragg peak orbit when needed. It ensures that each wave       vector is uniquely associated with a single Bragg peak orbit.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.metric_data_inconsistency","page":"API Reference","title":"ChargeFlipPhaser.metric_data_inconsistency","text":"metric_data_inconsistency(dd::DiffractionData{N,D,T})::Float64 where {N,D,T<:Integer}\n\nCheck for inconsistencies in the metric data of the DiffractionData object.\n\nDescription:\n\nFor the metric data md to be consistent with the symmetry group, the matrix r=md'*md must be invariant with respect to the action of the symmetry group G. Namely, for every  element g∈G, the following condition must hold: g.a'*r*g.a = r. This function computes  the matrix r and returns the tolerance to which this condition is satisfied.\n\nArguments:\n\ndd: The DiffractionData object to check.\n\nReturns:\n\nThe ratio of the maximal absolute value of of the elements of the matrix g.a'*r*g.a - r to the    trace of r. This value should be close to zero for the metric data to be consistent with the symmetry group.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ChargeFlipPhaser.physicalnorm","page":"API Reference","title":"ChargeFlipPhaser.physicalnorm","text":"physicalnorm(k::SVector{N, T}, dd::DiffractionData{N,D,T}) where {N,D,T<:Integer}\n\nCompute the norm of a physical wave vector corresponding to the integer vector kusing     the metric data of the DiffractionData object.\n\nArguments\n\nk: An integer wave vector (a vector of Miller indices).\ndd: The DiffractionData object containing the metric data.\n\nReturns:\n\nThe physical norm of the physical wave vector corresponding to k, calculated as norm(dd.md*k).\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Reflections","page":"API Reference","title":"Reflections","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.add_peak!","page":"API Reference","title":"ChargeFlipPhaser.add_peak!","text":" add_peak!(dd::DiffractionData{N,D,T}, k::SVector{N,T}, I::AbstractFloat)\n\nAdd a new orbit of Bragg peaks to the DiffractionData object.\n\nDescription:\n\nThis function creates a new BraggPeaksOrbit object corresponding to the wave vector k and adds it to the DiffractionData object dd. If the wave vector is already present in the diffraction data, it will not be added again. The function checks if the orbit is extinct (i.e., if it belongs to an extinct orbit) and throws an error if so.\n\nIf the wave vector belongs to an extinct orbit, the function will     throw an ArgumentError.\n\nArguments:\n\ndd: The DiffractionData object to which the Bragg peak will be added.\nk: A vector representing the wave vector of the Bragg peak.\nI: The intensity of the Bragg peak.\n\nReturns:\n\n- the number of Bragg peaks in the added orbit. If the wavevector is already\ntaken into account, the function will return 0.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Form-factors","page":"API Reference","title":"Form factors","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.WeightedF0","page":"API Reference","title":"ChargeFlipPhaser.WeightedF0","text":"WeightedF0\n\nA callable object representing the weighted non-dispersive part of the atomic  scattering factor for a material of a given composition.\n\nFields\n\nv: A vector of tuples, where each tuple contains the F0WaasKirf object for \n\nan atom or ion and the fraction of this type of atoms in the material.\n\nConstructors\n\nWeightedF0(c::Vector{Tuple{String, Float64}}): Creates a WeightedF0 object \n\nfrom a vector of tuples, where each tuple contains the chemical symbol of the  atom or ion and its fraction in the material.\n\nExample\n\nThe object should be called with a single real argument κ = sin(θ)  λ.\n\njulia> w=WeightedF0([(\"As\", 1.0), (\"Ga\", 1.0)]); [w(κ) for κ in 0.0:0.2:1.0]\n6-element Vector{Float64}:\n 32.00163144733964\n 25.58541327156792\n 19.004924495418177\n 13.806263061220022\n 10.184215575459087\n  8.03425166926575\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.formfactors_synthetic","page":"API Reference","title":"ChargeFlipPhaser.formfactors_synthetic","text":"formfactors_synthetic(dd::DiffractionData, windowing_function::Function)::Vector{Float64}\n\nComputes the regularizing part of the form factors to use with the diffraction data.\n\nArguments\n\ndd::DiffractionData: The diffraction data object.\nwindowing_function::Function: The regularizing windowing function to apply.\n\nReturns\n\nA vector of form factors.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#Running-the-program","page":"API Reference","title":"Running the program","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.Phaser","page":"API Reference","title":"ChargeFlipPhaser.Phaser","text":"Phaser{N}\n\nData structure representing the phaser state.\n\nFields\n\ndd: The diffraction data object.\nreal_orbits: The indices of the real orbits in the diffraction data.\ncomplex_orbits: The indices of the complex orbits in the diffraction data.\nv: The generator of the cyclic sampling grid.\nnumamps: The number of 1D amplitudes, not counting the antipodes and the zero wavevector.\nampl: The vector of the absolute values of amplitudes, in the order of orbits in dd.\np2f_r: Sparse matrix used to set amplitudes for real orbits.\np2f_c1: Sparse matrix used to set amplitudes for complex orbits.\np2f_c2: Sparse matrix used to set amplitudes for complex orbits, conjugated.\nf: The vector of phased amplitudes (on the reciprocal sampling grid)\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.ball_autocorr","page":"API Reference","title":"ChargeFlipPhaser.ball_autocorr","text":"ball_autocorr(x::Float64)::Float64\n\nSpherical ball autocorrelation function\n\nComputes the autocorrelation function of the indicator functions of two  three-dimensional spherical balls of diameter 1. The result is normalized  to 1 at the origin.\n\nArguments\n\nx: The distance from the center of the balls, normalized to the radius \n\n(which is 0.5).\n\nReturns\n\nFloat64: The value of the autocorrelation function at distance x.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ChargeFlipPhaser.do_phasing!","page":"API Reference","title":"ChargeFlipPhaser.do_phasing!","text":"do_phasing!(phaser::Phaser; algorithm::AbstractPhasingAlgorithm,\nhooks::AbstractHooks=DefaultHooks(), saver::AbstractSaver=DefaultSaver(),\nmax_iterations::Int=1000)\n\nPerform the phasing algorithm on the given Phaser object.\n\nArguments\n\nphaser: The Phaser object to modify.\nalgorithm: The phasing algorithm to use.\nhooks: The hooks to call during the phasing process.\nsaver: The saver to use for saving results.\nmax_iterations: The maximum number of iterations to perform.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#GUI-monitor","page":"API Reference","title":"GUI monitor","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.PhasingMonitor","page":"API Reference","title":"ChargeFlipPhaser.PhasingMonitor","text":"PhasingMonitor\n\nGUI monitor for the phasing application.\n\nFields\n\nfig::Figure   Makie Figure representing the monitor's GUI window.\nops::Observable{PhasingStatus}   Observable triggering widget redraws whenever the phasing status changes.\nolimits::Observable{Tuple{Float64, Float64}}   Observable for the extrema of the charge density, used to update the corresponding label in the GUI.\nc::Condition   Condition object used to notify the main program about user events.\nstate::Observable{MonitorState}   Current state of the monitor window (Created, Running, or Paused).\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.Cut2D","page":"API Reference","title":"ChargeFlipPhaser.Cut2D","text":"Cut2D{N}\n\nRepresentation of a 2D section (cut) of the charge density in an N-dimensional lattice.\n\nType Parameters\n\nN: The dimension of the problem.\n\nFields\n\ndirection::SMatrix{2,N}   A 2×N matrix whose columns are the lattice vectors spanning the cutting plane.\norigin::SVector{N,Float64}   Coordinates of the origin of the cutting plane in N-dimensional space.\nsize::Tuple{Int,Int}   The dimensions of the grid on which the density cut is computed.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.add_panel!","page":"API Reference","title":"ChargeFlipPhaser.add_panel!","text":"add_panel!(pm::PhasingMonitor, (i, j)::Tuple, cut::Cut2D, title::String, aspect::Real)\n\nAdd a panel to the GUI monitor window to visualize a 2D section of the charge density.\n\nThe panel is placed at grid position (i, j) within the monitor layout and is dynamically updated whenever the phasing status or charge-density limits change.\n\nArguments\n\npm::PhasingMonitor: The monitor window to which the panel will be added.\n(i, j)::Tuple: Grid coordinates (row, column) in the monitor's layout.\ncut::Cut2D: The specification of the 2D section to visualize.\ntitle::String: Title displayed above the panel.\naspect::Real: Aspect ratio of the panel's axes.\n\nNotes\n\nThe charge density cut is computed using a Cutter constructed from pm's current Phaser.\nPanel content updates automatically via observables linked to pm.ops and pm.olimits.\nDecorations are hidden for a cleaner visual layout.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ChargeFlipPhaser.display","page":"API Reference","title":"ChargeFlipPhaser.display","text":"display(pm::PhasingMonitor)\n\nDisplay the GUI window of a phasing monitor.\n\nThis calls Base.display on the underlying Makie figure (pm.fig), bringing up the monitor window for user interaction.\n\nArguments\n\npm::PhasingMonitor: The monitor whose GUI window should be displayed.\n\n\n\n\n\n","category":"function"},{"location":"api/public/#ChargeFlipPhaser.MonitorHooks","page":"API Reference","title":"ChargeFlipPhaser.MonitorHooks","text":"MonitorHooks <: AbstractHooks\n\nHooks for integrating the phasing workflow with a PhasingMonitor GUI.\n\nMonitorHooks wraps a PhasingMonitor instance and can be passed to the phasing engine so that GUI updates occur automatically at key points in the workflow.\n\nFields\n\npm::PhasingMonitor   The GUI monitor window to be updated during phasing.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#Custom-phasing-algorithms","page":"API Reference","title":"Custom phasing algorithms","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.AbstractPhasingAlgorithm","page":"API Reference","title":"ChargeFlipPhaser.AbstractPhasingAlgorithm","text":"AbstractPhasingAlgorithm\n\nAbstract supertype for all phasing algorithms in ChargeFlipPhaser.\n\nTo define a new algorithm, create a subtype:\n\nstruct MyAlgorithm <: AbstractPhasingAlgorithm\n    # fields\nend\n\nand implement the following methods:\n\nflip_charge!(rho::Vector{Float64}, algorithm::MyAlgorithm)\nflip_amplitudes!(wa::WorkingAmplitudes, algorithm::MyAlgorithm)\n\nThese methods are part of the ChargeFlipPhaser API. They should be either imported before definition:\n\n    import ChargeFlipPhaser: flip_charge!, flip_amplitudes!\n\nor defined with the module prefix:\n\n    function ChargeFlipPhaser.flip_charge!(...)\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.WorkingAmplitudes","page":"API Reference","title":"ChargeFlipPhaser.WorkingAmplitudes","text":"WorkingAmplitudes\n\nContainer for observed, working, and backprojected amplitudes used in the phasing workflow.\n\nFields\n\na_r::Vector{Float64}   Observed amplitudes for the real orbits.\na_c::Vector{Float64}   Observed amplitudes for the complex orbits.\nf_r::Vector{Float64}   Current working amplitudes for the real orbits.\nf_c::Vector{ComplexF64}   Current working amplitudes for the complex orbits.\nf_r_back::Vector{ComplexF64}   Backprojected amplitudes for the real orbits.\nf_c_back::Vector{ComplexF64}   Backprojected amplitudes for the complex orbits.\n\nConstructors\n\nWorkingAmplitudes(phaser::Phaser): Create a new WorkingAmplitudes object from a Phaser object.\n\n\n\n\n\n","category":"type"},{"location":"api/public/#Modifying-program-behavior","page":"API Reference","title":"Modifying program behavior","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.AbstractHooks","page":"API Reference","title":"ChargeFlipPhaser.AbstractHooks","text":"AbstractHooks\n\nAbstract supertype for hooks used in the phasing process. To define a new hooks type, create a subtype:\n\nstruct MyHooks <: AbstractHooks\n    # fields\nend\n\nand implement the following methods:\n\non_go(hooks::MyHooks)\non_show(hooks::MyHooks, phaser::Phaser,  ρ::Vector{Float64}, iteration::Int)\nis_done(hooks::MyHooks)\n\nThese methods are part of the ChargeFlipPhaser API. They should be either imported before definition:\n\n    import ChargeFlipPhaser: on_go, on_show, is_done\n\nor defined with the module prefix:\n\n    function ChargeFlipPhaser.on_show(...)\n\n\n\n\n\n","category":"type"},{"location":"api/public/#Saving-results","page":"API Reference","title":"Saving results","text":"","category":"section"},{"location":"api/public/#ChargeFlipPhaser.AbstractSaver","page":"API Reference","title":"ChargeFlipPhaser.AbstractSaver","text":"AbstractSaver\n\nAbstract supertype for saving results. To define a new saver type, create a subtype:\n\nstruct MySaver <: AbstractSaver\n    # fields\nend\n\nand implement the following method:\n\nfunction save_result(saver::MySaver, phaser::Phaser, wa::WorkingAmplitudes)\n\nThis method is part of the ChargeFlipPhaser API. It should be either imported before definition:\n\n    import ChargeFlipPhaser: save_result\n\nor defined with the module prefix:\n\n    function ChargeFlipPhaser.save_result(...)\n\n\n\n\n\n","category":"type"},{"location":"api/public/#ChargeFlipPhaser.CSVSaver","page":"API Reference","title":"ChargeFlipPhaser.CSVSaver","text":"CSVSaver <: AbstractSaver\n\nType for saving results in CSV format.\n\nFields\n\noutput_file_path: The path to the output CSV file where results will be saved.\n\n\n\n\n\n","category":"type"}]
}
